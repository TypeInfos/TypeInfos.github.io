---
title: '中级前端工程师面试题'
  # 大标题
sidebarDepth: 2
sidebar: auto
categories: frontEnd
# 分类 共有三个分类： frontEnd work hobby
date: 2019-02-12
# 时间
tags:
- 前端
- 中级前端工程师
- 面试题
# 标签
---

::: tip 概述
:::

## 在JS中定义枚举的首选语法是什么
::: tip Object.freeze
Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。
:::
我们平常都是用`const`来定义对象枚举，但是`const`对应的对象的值还是可以改动的，所以Object.freeze更适合枚举。
```js
const obj = {
  prop: 42
};

Object.freeze(obj);

obj.prop = 33;
// Throws an error in strict mode

console.log(obj.prop);
// expected output: 42
```
**Object.freeze并没有递归冻结对象。**
```js
let obj1 = {
  internal: {
    a:123
  }
};

Object.freeze(obj1);
obj1.internal.a = 'aValue';

obj1.internal.a // 'aValue'
```
## JS按位取反操作符~
### 预备知识
::: tip
计算机中没法做减法的，它的减法是通过加法来实现，需要加上一个负数，所以不得不引入一个符号位。
:::
### 原码
::: tip
是最简单的机器数表示法。用最高位表示符号位，‘1’表示负号，‘0’表示正号。其他位存放该数的二进制的绝对值。
:::
以带符号位的四位二进制值数为例：
::: tip
1010: 最高位为'1'，表示这是一个负数，其他三位'010'，即`（0*2^2）+（1*2^1）+（0*2^0）=2`（‘^’表示幂运算符）所以1010表示十进制数（-2）。
:::
下图给出部份正负数数的二进制原码表示法
![](../../.vuepress/public/binary-one.png)
既然都有正负数了，那么我们开始运算:
::: tip
0001+0010=0011    （1+2=3）
0000+1000=1000    （+0+（-0）=-0）
0001+1001=1010    （1+（-1）=-2）出现问题
:::
于是我们可以看到其实正数之间的加法通常是不会出错的，因为它就是一个很简单的二进制加法。

而正数与负数相加，或负数与负数相加，就要引起莫名其妙的结果，这都是该死的符号位引起的。0分为+0和-0也是因他而起。

所以原码，虽然直观易懂，易于正值转换。但用来实现加减法的话，运算规则总归是太复杂。于是反码来了。
### 反码
::: tip
我们知道，原码最大的问题就在于一个数加上他的相反数不等于零。
:::
例如：0001+1001=1010 (1+(-1)=-2) 0010+1010=1100 (2+(-2)=-4)
::: tip
反码：正数的反码还是等于原码<br>
负数的反码就是他的原码除符号位外，按位取反，例子：<br>
3是正数，反码与原码相同，则可以表示为0011<br>
-3的原码是1011，符号位保持不变，低三位（011）按位取反得（100）<br>
所以-3的反码为1100<br>
:::
那我们再试下，用反码的方式解决一下原码的问题：
::: tip
0001+1110=1111 （1+（-1）= - 0）

互为相反数相加等于0，解决。虽然是得到的结果是1111也就是-0，所以还不是很精确
:::
好，我们再试着做一下两个负数相加
::: tip
1110（-1）+ 1101（-2）= 1011（-4）
:::
-1 + (-2) = -4 ?
为了解决以上问题，补码就登场了。
### 补码
::: tip 补码定义
正数的补码等于他的原码

负数的补码等于反码+1
:::
在《计算机组成原理中》，补码的另外一种算法 是
::: tip
负数的补码等于他的原码自低位向高位，尾数的第一个‘1’及其右边的‘0’保持不变，左边的各位按位取反，符号位不变。

那正数的补码呢？加上一个正数，加法器就直接可以实现。所以它的补码就还是它本身。
:::
**补码实例**
![](../../.vuepress/public/binary-two.png)
现在来看几个例子:
::: tip 负数相加
1111（-1）+1110（-2）=1101(-3)
:::
::: tip 正负数相加
1000（-8） +0011（3）=1011(-5)

1110 (-2) + 0011(3) = 0001(1)
:::
### ~运算符
::: tip
作用于补码，将每一位二进制都取反:

~5: ~0101(5) => 1010(-6)
~-1: ~1111(-1) => 0000(0)
~0:~0000(0) => 1111(-1)
:::
经常被用到indexOf，如果是没有找到返回-1时，可以用`!~-1`表示`true`

## 实现一个完美的Promise
### Promise/A+规范
::: tip
1. 'promise'是一个对象或者函数
2. 'thenable'是一个对象或者函数
3. 'value'是promise状态成功时的值
4. 'reason'是promise状态失败时的值
:::
### 要求
1. 一个promise必须有3个状态，pending，fulfilled(resolved)，rejected当处于pending状态的时候，可以转移到fulfilled(resolved)或者rejected状态。当处于fulfilled(resolved)状态或者rejected状态的时候，就不可变。
2. 一个promise必须有一个then方法，then方法接受两个参数：<br>
其中onFulfilled方法表示状态从pending——>fulfilled(resolved)时所执行的方法，而onRejected表示状态从pending——>rejected所执行的方法。<br>
`promise.then(onFulfilled,onRejected)`
3. 为了实现链式调用，then方法必须返回一个promise
`promise2=promise1.then(onFulfilled,onRejected)`

超链接 [文本](URL)
<!-- ../../.vuepress/public/line-height.png) -->
图片 ![](url)

